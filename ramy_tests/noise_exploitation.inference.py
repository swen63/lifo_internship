# @author: Ramy CHEMAK
# @university: INSA Centre Val de Loire et Université d'Orléans
# @laboratory: Laboratoire d'Informatique Fondamentale d'Orléans (LIFO-EA 4022)


from noise_exploitation_algos import *
from manual import extract_record
from pyfiglet import Figlet, figlet_format
import pprint

from gdascore.gdaAttack import gdaAttack
from gdascore.gdaTools import setupGdaAttackParameters
from gdascore.gdaScore import gdaScores
from gdascore.gdaTools import setupGdaAttackParameters, comma_ize, finishGdaAttack

pp = pprint.PrettyPrinter(indent=4)

def noise_exploitation_attack(type, params, verbose, spec_params):
    """
    'spec_params' is a table of specific parameters according to attack type
    """
    if type == "differential":
        cols = spec_params[0].keys()
        rec = spec_params[0].values()
        s = spec_params[1]
        bins = spec_params[0][s]
        launch_differential_attack(params, verbose, cols, rec, s, bins)
    elif type == "cloning":
        launch_cloning_attack(params, verbose)
    elif type == "greedy":
        launch_greedy_cloning_attack(params, verbose)

def launch_differential_attack(params, verbose, tab1, tab2, s, bins):
    # Check on parameters
    print("########## Parameters passed ##########")
    pp.pprint(params)
    # Attack setup
    attack = gdaAttack(params)
    attack.unsetVerbose()
    print("\nInfo >>> Attack Class created\n")
    # Information gathering
    table = attack.getAttackTableName()
    rawColNames = attack.getColNames(dbType="rawDb")
    anonColNames = attack.getColNames(dbType="anonDb")
    print(f"\nInfo >>> Working on table : {table} ...")
    # Preparing attack parameters
    a_cols_star = tab1
    x_a_star = tab2
    #s = "frequency" # to be eliminated
    # Executing attack
    attack_result = full_differential_attack(attack, a_cols_star, x_a_star, s, bins)
    if attack_result == None:
        print("Attribute Non Attackable (launch level)")
        return None
    '''if attack_result:
        attack_result = 1
    else:
        attack_result = 0'''
    # Make the guess according to attack result
    print("\nInfo >>> Making claims ...\n")
    spec = {}
    guess = []
    for i in range(len(a_cols_star)):
        guess.append({'col':a_cols_star[i],'val':x_a_star[i]})
    guess.append({'col':s,'val':attack_result})
    spec['guess'] = guess
    attack.askClaim(spec, claim=True)
    while True:
        claim = attack.getClaim()
        if claim["stillToCome"]==0:
            break
    # Compute and display score
    result = attack.getResults()
    gda_score = gdaScores(result)
    print("\nInfo >>> Score Class created\n")
    print("########## Attack score ##########")
    score = gda_score.getScores()
    if verbose:
        pp.pprint(score)
    # Abschliessung
    attack.cleanUp()
    final_result = finishGdaAttack(params, score)
    return None

def launch_cloning_attack(params, verbose):
    # Check on parameters
    print("########## Parameters passed ##########")
    pp.pprint(params)
    # Attack setup
    attack = gdaAttack(params)
    attack.unsetVerbose()
    print("\nInfo >>> Attack Class created\n")
    # Information gathering
    table = attack.getAttackTableName()
    rawColNames = attack.getColNames(dbType="rawDb")
    anonColNames = attack.getColNames(dbType="anonDb")
    print(f"\nInfo >>> Working on table : {table} ...")
    # Preparing attack parameters
    a_cols_star = []
    x_a_star = []
    delta = []
    s = "attribute"
    v = "value"
    # Executing attack
    attack_result = full_cloning_attack(attack, a_cols_star, x_a_star, delta, s, v)
    if attack_result == None:
        print("Attribute Non Attackable")
        return None
    # Make the guess according to attack result
    print("\nInfo >>> Making claims ...\n")
    spec = {}
    guess = []
    for i in range(len(a_cols_star)):
        guess.append({'col':a_cols_star[i],'val':x_a_star[i]})
    guess.append({'col':s,'val':v})
    spec['guess'] = guess
    attack.askClaim(spec, claim=attack_result)
    while True:
        claim = attack.getClaim()
        if claim["stillToCome"]==0:
            break
    # Compute and display score
    result = attack.getResults()
    gda_score = gdaScores(result)
    print("\nInfo >>> Score Class created\n")
    print("########## Attack score ##########")
    score = gda_score.getScores()
    if verbose:
        pp.pprint(score)
    # Abschliessung
    attack.cleanUp()
    final_result = finishGdaAttack(params, score)
    return None

def launch_greedy_cloning_attack(params, verbose):
    # Check on parameters
    print("########## Parameters passed ##########")
    pp.pprint(params)
    # Attack setup
    attack = gdaAttack(params)
    attack.unsetVerbose()
    print("\nInfo >>> Attack Class created\n")
    # Information gathering
    table = attack.getAttackTableName()
    rawColNames = attack.getColNames(dbType="rawDb")
    anonColNames = attack.getColNames(dbType="anonDb")
    print(f"\nInfo >>> Working on table : {table} ...")
    # Preparing attack parameters
    a_cols_star = []
    x_a_star = []
    delta = []
    s = "attribute"
    v = "value"
    # Executing attack
    attack_result = full_cloning_attack(attack, a_cols_star, x_a_star, delta, s, v)
    if attack_result == None:
        print("Attribute Non Attackable")
        return None
    # Make the guess according to attack result
    print("\nInfo >>> Making claims ...\n")
    spec = {}
    guess = []
    for i in range(len(a_cols_star)):
        guess.append({'col':a_cols_star[i],'val':x_a_star[i]})
    guess.append({'col':s,'val':v})
    spec['guess'] = guess
    attack.askClaim(spec, claim=attack_result)
    while True:
        claim = attack.getClaim()
        if claim["stillToCome"]==0:
            break
    # Compute and display score
    result = attack.getResults()
    gda_score = gdaScores(result)
    print("\nInfo >>> Score Class created\n")
    print("########## Attack score ##########")
    score = gda_score.getScores()
    if verbose:
        pp.pprint(score)
    # Abschliessung
    attack.cleanUp()
    final_result = finishGdaAttack(params, score)
    return None

def get_database_scheme(params, verbose):
    """
    Description:
    Used for differential attacks
    Output:
    * dict 'attack_cols' looks like {'gender': ['Female', 'Male']}
    All values length is 2 (differential attackable columns)
    * dict 'record' looks like {'duration':12, 'gender':'Male'}
    """
    # Check on parameters
    print("########## Parameters passed (Scheme) ##########")
    #pp.pprint(params)
    # Attack setup
    attack = gdaAttack(params)
    attack.unsetVerbose()
    print("\nInfo >>> Attack Class created\n")
    # Information gathering
    table = attack.getAttackTableName()
    rawColNames = attack.getColNames(dbType="rawDb")
    anonColNames = attack.getColNames(dbType="anonDb")
    print(f"\nInfo >>> Working on table : {table} ...")
    cols = [] # to be used later for an SQL query
    attack_cols = dict() # theoritically attackable cols (differential) to test
    for col in rawColNames: # to be replaced by anonColNames ...
        publicValues = attack.getPublicColValues(col, table)
        values = []
        if publicValues:
            cols.append(col)
        for t in publicValues:
            values.append(t[0])
        #print(f"## {col} ({len(values)}) >> {values}")
        # automatic fill in
        if len(values)==2:
            print(f"## {col} ({len(values)}) >> {values}")
            attack_cols[col] = values
        #print(f"{col} >> {publicValues}")
    print("\nInfo >>> Selecting a random record ...")
    query = {}
    query['db'] = "anonDb"
    sql = sqlQueryGen(table, cols, None, None, False)
    query['sql'] = sql
    print(f"\nInfo >>> Asking SQL query : '{sql}' ...")
    attack.askAttack(query)
    #print("debug 01")
    reply = attack.getAttack()
    #print("debug 02 !>", len(reply))
    answer = random.choice(reply['answer'])
    if len(cols) != len(answer):
        print(f"\nError >>> Lengths of columns ({len(cols)}) and record ({len(answer)}) not matching")
    print(f"\nInfo >>> Chosen record ...")
    record = dict()
    for i in range(len(cols)):
        record[cols[i]] = answer[i]
        print(f"{cols[i]} = {answer[i]}")
    return (attack_cols, record)

def get_database_scheme_v2(params, verbose):
    """
    Description:
    Used for cloning attacks
    Output:
    * dict 'attack_cols' looks like {'gender': ['Female', 'Male']}
    All values length is 2 (differential attackable columns)
    * dict 'record' looks like {'duration':12, 'gender':'Male'}
    """
    # Check on parameters
    print("########## Parameters passed (Schema) ##########")
    #pp.pprint(params)
    # Attack setup
    attack = gdaAttack(params)
    attack.unsetVerbose()
    print("\nInfo >>> Attack Class created\n")
    # Information gathering
    table = attack.getAttackTableName()
    rawColNames = attack.getColNames(dbType="rawDb")
    anonColNames = attack.getColNames(dbType="anonDb")
    print(f"\nInfo >>> Working on table : {table} ...")
    cols = [] # to be used later for an SQL query
    attack_cols = dict() # theoritically attackable cols (differential) to test
    for col in anonColNames: # to be replaced by anonColNames ...
        publicValues = attack.getPublicColValues(col, table)
        values = []
        if publicValues:
            cols.append(col)
        for t in publicValues:
            values.append(t[0])
        attack_cols[col] = values
        print(f"## {col} ({len(values)}) >> {values}")
    print("\nInfo >>> Selecting a random record ...")
    query = {}
    query['db'] = "anonDb"
    sql = sqlQueryGen(table, cols, None, None)
    query['sql'] = sql
    print(f"\nInfo >>> Asking SQL query : '{sql}' ...")
    attack.askAttack(query)
    reply = attack.getAttack()
    answer = random.choice(reply['answer'])
    if len(cols) != len(answer):
        print(f"\nError >>> Lengths of columns ({len(cols)}) and record ({len(answer)}) not matching")
    print(f"\nInfo >>> Chosen record ...")
    record = dict()
    for i in range(len(cols)):
        record[cols[i]] = answer[i]
        print(f"{cols[i]} = {answer[i]}")
    print("Info >>> Getting schema done ...")
    print("... ", attack_cols)
    return (attack_cols, record)


config = {
    "basic": {
        "attackType": "Differential noise-exploitation Attack",
        "criteria": "inference"
    },
    'anonTypes': [
        #["no_anon"],
        ["pseudonymization", "latest"],
        ["diffix","latest"],
        ["diffix","v19_1_0"],
        ["k_anonymization","naive","k_2"],
        ["k_anonymization","naive","k_5"],
        ["pseudonymization","colSuppression"],
        ["pseudonymization","kanon","k_2"],
        ["pseudonymization","kanon","k_5"]
    ],
    'tables': [
        ['banking','accounts'],
        ['banking','loans'],
        #['banking','transactions'],
        #['taxi','rides'],
        #['census','persons'],
        #['scihub','downloads']
    ]
}

# set general configuration parameters
paramsList = setupGdaAttackParameters(config)
params = paramsList[0]
verbose = False # set verbose
type = "cloning" # set attack type

# launch attack
#noise_exploitation_attack(type, params, verbose)
'''(cols, record) = get_database_scheme(params, verbose)
tab = []
for i in range(len(cols)):
    if cols[i] == 'sex':
        continue
    tab[i] = record[i]'''

#scheme = get_database_scheme(params, verbose)

'''s = "disp_type"
bins = ["OWNER", "DISPONENT"]
man = extract_record(col_s=s)
cols = man[0]
rec = man[1]
launch_differential_attack(params, verbose, cols, rec, s, bins)
'''

schema = get_database_scheme_v2(params, verbose)[0]
#delta = dummyConditionGen(schema, 'frequency', 5)
#print("Delta : ", delta)
