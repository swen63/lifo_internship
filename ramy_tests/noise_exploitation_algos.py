# @author: Ramy CHEMAK
# @university: INSA Centre Val de Loire et Université d'Orléans
# @laboratory: Laboratoire d'Informatique Fondamentale d'Orléans (LIFO-EA 4022)


import pprint
import random
import string
from math import exp, sqrt, pi, floor

from gdascore.gdaAttack import gdaAttack
from gdascore.gdaTools import setupGdaAttackParameters
from gdascore.gdaScore import gdaScores
from gdascore.gdaTools import setupGdaAttackParameters, comma_ize, finishGdaAttack

pp = pprint.PrettyPrinter(indent=4)

# --------------------------------------------------------------
# Implementation of the Differential noise-exploitation attacks:
# * Differential Attack
# * Cloning Attack
# * Optimized Cloning Attack (using greedy subset selection)
# --------------------------------------------------------------

def differential_attack(attack, a_cols, x_a, s, bins=[False, True]):
    """
    Params:
    'a_cols' is A a set of attributes, a subset of the column list
    'x_a' is the restriction of the record x to A, a list of values for A attributes
    's' is the secret attribute not belonging to A, for which we would like to guess the value
    'bin1' and 'bin2' represent the only two possible values for 's'
    Output:
    Value of s: True of False
    """
    bin1 = bins[0] # same as False
    bin2 = bins[1] # same as True
    #bin1 = "POPLATEK MESICNE"
    #bin2 = "POPLATEK TYDNE"
    k = len(a_cols) # cardinal of A
    q = [] # represents Q
    r = [] # represents R
    conditions_all = [] # list of all possible conditions
    for i in range(k):
        conditions_all.append(f"{a_cols[i]}={x_a[i]}")
    for j in range(k):
        # prepare the conditions and the queries whom replies are to count
        conditions = []
        for i in range(k):
            if i==j:
                except_cond = f"{a_cols[i]}<>{x_a[i]}"
            conditions.append(conditions_all[i])
        if type(a)==str:
            conditions.append(f"{s}='{bin1}'")
        else:
            conditions.append(f"{s}={bin1}")
        table = attack.getAttackTableName()
        sql = sqlQueryGen(table, a_cols, conditions, ' AND ')
        conditions.append(except_cond)
        sql_prime = sqlQueryGen(table, a_cols, conditions, ' AND ')
        # execute the queries and count their results
        query = {}
        query['db'] = "anonDb"
        #query['sql'] = f"SELECT count(DISTINCT ({sql}))"
        query['sql'] = sql
        attack.askAttack(query)
        reply = attack.getAttack()
        #query['sql'] = f"SELECT count(DISTINCT ({sql_prime}))"
        query['sql'] = sql_prime
        attack.askAttack(query)
        reply_prime = attack.getAttack()
        #print("debug 01 start")
        #print(reply)
        #print("debug 01 end")
        if len(reply['answer'])>0 and len(reply_prime['answer'])>0:
            #qj = int(reply) - int(reply_prime)
            qj = len(reply['answer']) - len(reply_prime['answer'])
            if qj not in q:
                q.append(qj)
    for j in range(k):
        # prepare the conditions and the queries whom replies are to count
        conditions = []
        for i in range(k):
            if i==j:
                except_cond = f"{a_cols[i]}<>{x_a[i]}"
            conditions.append(conditions_all[i])
        conditions.append(f"{s}='{bin2}'")
        table = attack.getAttackTableName()
        sql = sqlQueryGen(table, a_cols, conditions, ' AND ')
        conditions.append(except_cond)
        sql_prime = sqlQueryGen(table, a_cols, conditions, ' AND ')
        # execute the queries and count their results
        query = {}
        query['db'] = "anonDb"
        #query['sql'] = f"SELECT count(DISTINCT ({sql}))"
        query['sql'] = sql
        attack.askAttack(query)
        while  True:
            reply = attack.getAttack()
            if reply['stillToCome']==0:
                break
        print("# DEBUG: ", len(reply))
        pp.pprint(reply)
        #query['sql'] = f"SELECT count(DISTINCT ({sql_prime}))"
        query['sql'] = sql_prime
        attack.askAttack(query)
        while  True:
            reply_prime = attack.getAttack()
            if reply['stillToCome']==0:
                break
        if len(reply['answer'])>0 and len(reply_prime['answer'])>0:
            #rj = int(reply) - int(reply_prime)
            rj = len(reply['answer']) - len(reply_prime['answer'])
            if rj not in r:
                r.append(rj)
    if (not r) and (not q):
        return None
    # some computations ...
    l = 1
    for e in q:
        l *= f(e) / g(k, e)
    for e in r:
        l *= f(e) / g(k, e)
    if l >= 1:
        return bin2
    else:
        return bin1
    #return l>=1

def f(x):
    """ Probability density function of normal distribution (0, 2)
    PDF of N(0, 2) """
    e = (x/2)**2
    return exp(-e)/(2*sqrt(pi))

def g(k, x):
    """ Probability density function of normal distribution (1, 2k+2)
    PDF of N(1, 2k+2) """
    d = 2 * sqrt(2*(k+1)*pi)
    e = (((x-1)/2)**2) / (k+1)
    return exp(-e)/d

def full_differential_attack(attack, a_cols_star, x_a_star, s, bins=[False, True]):
    """
    Description:
    The procedure would determines whether the possibility of a differential attack
    It launches the differential attack when possible
    Params:
    'a_cols_star' is A* a set of attributes, a subset of the column list
    'x_a_star' is the restriction of the record x to A*, a list of values for A* attributes
    's' is the secret attribute not belonging to A*, for which we would like to guess the value
    Output:
    If the attack is possible : Value of s (True of False)
    Otherwise : None
    """
    bin1 = bins[0] # same as False
    bin2 = bins[1] # same as True
    #bin1 = "POPLATEK MESICNE"
    #bin2 = "POPLATEK TYDNE"
    n = len(a_cols_star) # cardinal of A*
    for k in reversed(range(1, n+1)):
        for i in range(1, 101):
            buff = dict() # temp variable to fill in A and x(A) correctly
            for m in range(len(a_cols_star)):
                buff[a_cols_star[m]] = x_a_star[m]
            a_cols = random.sample(a_cols_star, k) # A: random subset of size (A*, k)
            x_a = [] # x(A), ie. corresponding values of A
            for e in a_cols:
                x_a.append(buff[e])
            #a_cols = a_cols_star[:k]
            #x_a = x_a_star[:k]
            if record_unique(attack, a_cols, x_a):
                print("Info >>> Attack seems to be possible ...")
                result = differential_attack(attack, a_cols, x_a, s, bins)
                if result==None:
                    #return result
                    continue
                print(f"Info >>> Round {k} : {i}")
                print("Info >>> Attack succeeded :)")
                print(f"... {result} is good")
                return result
                '''if result:
                    print(f"Info >>> {bin2} is good")
                else:
                    print(f"Info >>> {bin1} is good")'''
    print("Attribute Non Attackable (algorithm level)")
    return None

def cloning_attack(attack, a_cols, u, x_a, x_u, delta, s, v):
    """
    Params:
    'a_cols' is A' a set of attributes, a subset of the column list
    'u' is an attribute
    'x_a' is the restriction of the record x to A', a list of values for A* attributes
    'x_u' is the restriction of the record x to the attribute u, its value
    'delta' is a list of dummy conditions to apply in subsets for the testing queries
    's' is the secret attribute not belonging to A', for which we would like to guess the value
    'v' is the target value of the secret s we want to infer
    Output:
    If x(s)=v : True
    Otherwise : False
    """
    n = len(delta) # cardinal of delta
    list_qj = [] # list to store qj values at the end of each loop
    for j in range(1, n+1):
        # prepare the conditions and the queries whom replies are to count
        phi = [] # list of conditions upon which we would count the SQL replies
        for i in range(len(a_cols)):
            phi.append(f"{a_cols[i]}={x_a[i]}")
        for i in range(len(delta)):
            if i==j:
                continue
            phi.append(delta[i])
        phi.append(f"{s}<>{v}")
        table = attack.getAttackTableName()
        sql = sqlQueryGen(table, a_cols, phi, ' AND ')
        phi.append(f"{u}<>{x_u}")
        sql_prime = sqlQueryGen(table, a_cols, phi, ' AND ')
        # execute the queries and count their results
        query = {}
        query['db'] = "anonDb"
        query['sql'] = f"SELECT count(DISTINCT ({sql}))"
        attack.askAttack(query)
        reply = attack.getAttack()
        query['sql'] = f"SELECT count(DISTINCT ({sql_prime}))"
        attack.askAttack(query)
        reply_prime = attack.getAttack()
        qj = int(reply) - int(reply_prime)
        list_qj.append(qj)
    # some computations ...
    r_bar = 0
    s2 = 0
    for e in list_qj:
        r_bar += e
    r_bar = r_bar / n
    for e in list_qj:
        s2 += (e - r_bar)**2
    s2 = s2 / (n-1)
    gamma = sqrt(2*len(delta))
    return s2<=gamma

def full_cloning_attack(attack, a_cols_star, x_a_star, delta, s, v):
    """
    Description:
    The procedure would determines whether the possibility of a cloning attack
    It launches the cloning attack when possible
    Params:
    'a_cols_star' is A* a set of attributes, a subset of the column list
    'x_a_star' is the restriction of the record x to A*, a list of values for A* attributes
    'delta' is a list of dummy conditions to apply in subsets for the testing queries
    's' is the secret attribute not belonging to A', for which we would like to guess the value
    'v' is the target value of the secret s we want to infer
    Output:
    If the attack is possible : Result of the attack s=v (True of False)
    Otherwise : None
    """
    for k in reversed(range(1, len(a_cols_star)+1)):
        for i in range(1, 101):
            a_cols_temp = a_cols[:]
            u = random.choice(a_cols_temp)
            a_cols_temp.remove(u)
            a_cols = random.sample(a_cols_temp, k-1)
            x_a = [0] * len(a_cols)
            x_u = 0
            for m in range(len(a_cols_star)):
                if a_cols_star[m] in a_cols:
                    j = 0 # get index of this attribute in A'
                    while a_cols[j] != a_cols_star[m]:
                        j += 1
                    x_a[j] = x_a_star[m]
                if a_cols_star[m]==u:
                    x_u = x_a_star[m]
            if no_bucket_suppression(attack, a_cols, u, x_a, x_u, delta, s, v) and value_unique(attack, a_cols, u, x_a_star):
                return cloning_attack(attack, a_cols, u, x_a, x_u, delta, s, v)
    return None

def greedy_select_subset(attack, a_cols_star, x_a_star, s, v):
    """
    Params:
    'a_cols_star' is A* a set of attributes, a subset of the column list
    'x_a_star' is the restriction of the record x to A*, a list of values for A* attributes
    's' is the secret attribute not belonging to A', for which we would like to guess the value
    'v' is the target value of the secret s we want to infer
    Output:
    A tuple (A', u) of selected subset A' and selected attribute u
    """
    table = attack.getAttackTableName()
    sql = f"SELECT * FROM {table}"
    query = {}
    query['db'] = "anonDb"
    query['sql'] = f"SELECT count(DISTINCT ({sql}))"
    attack.askAttack(query)
    reply = attack.getAttack()
    n = int(reply) # approx. tot. number of users
    # selection
    rou_a = []
    for i in range(len(a_cols_star)):
        conditions = []
        conditions.append(f"{a_cols_star[i]}={x_a_star[i]}")
        conditions.append(f"{s}<>{v}")
        sql = sqlQueryGen(table, a_cols_star, conditions, ' AND ')
        query['sql'] = f"SELECT count(DISTINCT ({sql}))"
        attack.askAttack(query)
        reply = attack.getAttack()
        c_a = int(reply) # the count Ca
        rou_a.append(c_a/n)
    rou_a_sorted = rou_a[:]
    rou_a_sorted.sort()
    u = a_cols_star[-1]
    a_cols = []
    i = 1
    h = rou_a[-1]
    while h > (1/n):
        a_cols.append(a_cols_star[i])
        h *= rou_a_sorted[i]
        i += 1
    return (a_cols, u)

def greedy_full_cloning_attack(attack, a_cols_star, x_a_star, delta, s, v):
    """
    Description:
    Same as the full cloning attack
    In this version however we use a heuristic for the subset exploration
    Params:
    'a_cols_star' is A* a set of attributes, a subset of the column list
    'x_a_star' is the restriction of the record x to A*, a list of values for A* attributes
    'delta' is a list of dummy conditions to apply in subsets for the testing queries
    's' is the secret attribute not belonging to A', for which we would like to guess the value
    'v' is the target value of the secret s we want to infer
    Output:
    If the attack is possible : Result of the attack s=v (True of False)
    Otherwise : None
    """
    for k in reversed(range(1, len(a_cols_star)+1)):
        for i in range(1, 101):
            # get subset of attributes A' and attribute u
            (a_cols, u) = greedy_select_subset(attack, a_cols_star, x_a_star, s, v)
            # fill in restrictions of A' and u with their corresponding values
            x_a = [0] * len(a_cols)
            x_u = 0
            for i in range(len(a_cols_star)):
                if a_cols_star[i] in a_cols:
                    j = 0 # get index of this attribute in A'
                    while a_cols[j] != a_cols_star[i]:
                        j += 1
                    x_a[j] = x_a_star[i]
                if a_cols_star[i]==u:
                    x_u = x_a_star[i]
            # launch the tests
            if no_bucket_suppression(attack, a_cols, u, x_a, x_u, delta, s, v) and value_unique(attack, a_cols, u, x_a_star):
                return cloning_attack(attack, a_cols, u, x_a, x_u, delta, s, v)
    return None

def no_bucket_suppression(attack, a_cols, u, x_a, x_u, delta, s, v):
    """
    Params:
    'a_cols' is A' a set of attributes, a subset of the column list
    'u' is an attribute
    'x_a' is the restriction of the record x to A', a list of values for A* attributes
    'x_u' is the restriction of the record x to the attribute u, its value
    'delta' is a list of dummy conditions to apply in subsets for the testing queries
    's' is the secret attribute not belonging to A', for which we would like to guess the value
    'v' is the target value of the secret s we want to infer
    Output:
    If attributes A' and u validate assumption 1 : True
    Otherwise : False
    """
    ok = 0
    ok_prime = 0
    n = len(delta) # cardinal of delta
    for j in range(1, n+1):
        # prepare the conditions and the queries whom replies are to count
        phi = [] # list of conditions upon which we would count the SQL replies
        for i in range(len(a_cols)):
            phi.append(f"{a_cols[i]}={x_a[i]}")
        for i in range(len(delta)):
            if i==j:
                continue
            phi.append(delta[i])
        phi.append(f"{s}<>{v}")
        table = attack.getAttackTableName()
        sql = sqlQueryGen(table, a_cols, phi, ' AND ')
        phi.append(f"{u}<>{x_u}")
        sql_prime = sqlQueryGen(table, a_cols, phi, ' AND ')
        # execute the queries and count their results
        query = {}
        query['db'] = "anonDb"
        query['sql'] = f"SELECT count(DISTINCT ({sql}))"
        attack.askAttack(query)
        reply = attack.getAttack()
        query['sql'] = f"SELECT count(DISTINCT ({sql_prime}))"
        attack.askAttack(query)
        reply_prime = attack.getAttack()
        # treatment
        if int(reply)>0:
            ok = 1
        if int(reply_prime)>0:
            ok_prime = 1
    return ok==1 and ok_prime==1

def record_unique(attack, a_cols, record):
    """
    Params:
    'a_cols' is A a set of attributes
    'record' a list of values for A attributes
    Output:
    If x(A) is unique : True
    Otherwise : False
    """
    # prepare the query
    table = attack.getAttackTableName()
    conditions = [] # conditions upon which we would generate the SQL query
    for i in range(len(a_cols)):
        conditions.append(f"{a_cols[i]}={record[i]}")
    sql = sqlQueryGen(table, a_cols, conditions, ' AND ')
    # execute the query
    query = {}
    query['db'] = "anonDb"
    query['sql'] = sql
    #query['sql'] = f"SELECT count(DISTINCT ({sql}))"
    attack.askAttack(query)
    reply = attack.getAttack()
    #print("debug 01 start")
    #pp.pprint(reply['answer'])
    #print("debug 01 end")
    #print(type(reply['answer']))
    #print("debug 02")
    # validate the test according to assumption 2
    return len(reply['answer'])==1

def value_unique(attack, a_cols, u, x_a, x_u):
    """
    Params:
    'a_cols' is A a set of attributes
    'u' is an attribute
    'x_a' is the restriction of the record x to A, a list of values for A attributes
    'x_u' is the restriction of the record x to the attribute u
    Output:
    If x(A) is unique : True
    Otherwise : False
    """
    # prepare the query
    table = attack.getAttackTableName()
    conditions = [] # conditions upon which we would generate the SQL query
    for i in range(len(a_cols)):
        conditions.append(f"{a_cols[i]}={x_a[i]}")
    conditions.append(f"{u}={x_u}")
    sql = sqlQueryGen(table, a_cols, conditions, ' AND ')
    # execute the query
    query = {}
    query['db'] = "anonDb"
    query['sql'] = f"SELECT count(DISTINCT ({sql}))"
    attack.askAttack(query)
    reply = attack.getAttack()
    # validate the test according to assumption 2
    return int(reply)==0

def sqlQueryGen(table, cols, conditions, operator, opp=False):
    """
    Routine function to generate SQL queries
    If there is no conditions, parameter 'conditions' is set to None
    For a unique condition, 'conditions' is a string and 'operator' is set to None
    Else, 'conditions' is a table of strings and 'operator' is string
    """
    sql = "SELECT "
    sql += comma_ize(cols, lastComma=False)
    sql += " FROM " + table
    if conditions==None:
        return sql
    if operator==None:
        if opp:
            sql += " WHERE NOT(" + conditions + ")"
        else:
            sql += " WHERE " + conditions
    else:
        if opp:
            sql += " WHERE NOT(" + operator.join(conditions) + ")"
        else:
            sql += " WHERE " + operator.join(conditions)
    return sql

def dummyConditionGen(schema, s, n):
    """
    Description:
    Generate dummy conditions
    Input:
    'schema' is a dict of columns with all possible values
    It looks like {'gender': ['Female', 'Male'], 'freq': [12, 24, 36, 48]}
    """
    delta = [] # final dummy conditions
    for col in schema.keys():
        if not schema[col]:
            continue
        impValues = [] # impossible values
        # there are 2 cases to be treated, whether values are strings or not
        if type(schema[col][0])==str:
            for i in range(n):
                # compute average length of a value
                l = 0
                up = None
                for w in schema[col]:
                    l += len(w)
                    if w==w.upper():
                        up = True
                    elif w==w.lower():
                        up = False
                l /= len(schema[col])
                l = floor(l)
                nw = wordGen(l, up) # new generated word
                while nw in schema[col]:
                    nw = wordGen(l, up)
                impValues.append(nw)
            for iv in impValues:
                delta.append(f"{col}='{iv}'")
        elif type(schema[col][0])==int or type(schema[col][0])==float:
            m1 = min(schema[col])
            m2 = max(schema[col])
            for i in range(1, int(n/2)+1):
                impValues.append(m1-i)
                impValues.append(m2+i)
            for iv in impValues:
                delta.append(f"{col}={iv}")
    return delta

def wordGen(l, upper=None):
    """
    Generate a random word of length l
    """
    w = "".join(random.choice(string.ascii_letters) for _ in range(l))
    if upper:
        return w.upper()
    elif upper==False:
        return w.lower()
    else:
        return w


###############################
# incomplete version
def differential_attack_v2(attack, a_cols, x_a, s):
    """
    Params:
    'a_cols' is A a set of attributes, a subset of the column list
    'x_a' is the restriction of the record x to A, a list of values for A attributes
    's' is the secret attribute not belonging to A, for which we would like to guess the value
    Output:
    Value of s: True of False
    """
    k = len(a_cols) # cardinal of A
    q = [] # represents Q
    r = [] # represents R
    q_global = []
    r_global = []
    for j in range(1, k+1):
        cols_temp = []
        conds_temp = []
        for i in range(1, k+1):
            if i!=j:
                cols_temp.append(a_cols[i])
                conds_temp.append(f"{a_cols[i]}={x_a[i]}")
        sql = sqlQueryGen(table, cols_temp, conds_temp, " AND ")
        sql_prime = sqlQueryGen(table, cols_temp, conds_temp+["s=0"], " AND ")
        # launch both queries
        query = {}
        query['db'] = "anonDb"
        query['sql'] = f"SELECT count(DISTINCT ({sql}))"
        attack.askAttack(query)
        reply = attack.getAttack()
        query['sql'] = f"SELECT count(DISTINCT ({sql_prime}))"
        attack.askAttack(query)
        reply_prime = attack.getAttack()
        if int(reply)>0 and int(reply_prime)>0:
            qj = int(reply) - int(reply_prime)
            if qj not in q:
                q.append(qj)
            # we store difference (q_reply\q_prime_reply) in q_reply
            for rec in q_prime_reply:
                if rec in q_reply:
                    q_reply.remove(rec)
            q_global = q_global + q_reply
    for j in range(1, k+1):
        cols_temp = []
        conds_temp = []
        for i in range(1, k+1):
            if i!=j:
                cols_temp.append(a_cols[i])
                conds_temp.append(f"{a_cols[i]}={x_a[i]}")
        sql = sqlQueryGen(table, cols_temp, conds_temp, " AND ")
        sql_prime = sqlQueryGen(table, cols_temp, conds_temp+["s=1"], " AND ")
        # launch both queries
        query = {}
        query['db'] = "anonDb"
        query['sql'] = f"SELECT count(DISTINCT ({sql}))"
        attack.askAttack(query)
        r_reply = attack.getAttack()
        query['sql'] = f"SELECT count(DISTINCT ({sql_prime}))"
        attack.askAttack(query)
        r_prime_reply = attack.getAttack()
        if r_reply>0 and r_prime_reply>0:
            # we store difference (r_reply\r_prime_reply) in r_reply
            for rec in r_reply:
                if rec in r_prime_reply:
                    r_reply.remove(rec)
            r_global = r_global + r_reply
    if (not q_global) and (not r_global):
        return None
    # computations to add ...
    return True
